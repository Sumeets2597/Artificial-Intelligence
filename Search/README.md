# Report

## Part 1: The Luddy puzzle

The initial state is the board provided as input and the goal state is that all the tiles are arranged in ascending order and the empty tile is at the last position of board. The earlier algorithm was using bfs and was not at all optimised so we needed to use A* search approach to optimise the algorithm. In order to implement the A* search, we defined the heuristic as the number of misplaced tiles at each state! This heuristic is admissible as it underestimates the true cost and hence it is bound to find the optimal solution. The value of this heuristic is always less than or equal to the true cheapest cost and hence it is admissible.  

At first we defined a function which calculated the heuristic value of the state which is passed to that function. It does this by comparing that particular state with the goal state and calculating the number of misplaced tiles. We implemented a priority queue to store the successors of each state. We calculated the g(x) which was the number of nodes traversed so far by keeping track of the path. The f(x) for each successor was calculated which is the addition of the heuristic h(x) and g(x). While adding any successor to the priority queue, we also added its respective f(x) as the key. Hence, the priority queue gives the successor with the least f(x) and thus serving our purpose! At first we used the priority queue only for storing and picking successor and did not alter the fringe which was there in code. However, it was causing a lot of trouble and logical errors, so we removed the fringe entirely and implemented everything in priority queue.

Also, when the function used to find all the possible successors of a given state, it also considered the parent successor from where it just came! In some cases it used to return to that successors thus causing unnecessary redundant steps. Hence we maintained a list which kept track of previously visited nodes and enforced a condition to bypass the successors which are already visited. This reduced the state space by a great extent and the execution became a lost faster. For eg. a case with solution of 22 moves takes 1.85 seconds. For circular variant, the moves were the same as original. But in this variant, the empty tile can move in circular manner so we changed the successor function and defined the swapping tiles and valid moves again. The modulus was taken for 4, as when a particular move goes out of index, it can come around from other side of the board. For luddy variant, the set of moves totally changed and we defined all the set of moves for luddy variant as given in problem. 

One important problem we faced was when the algorithm was given a board which is not solvable! The code attempted to solve it and went into inifinite loop without providing any kind of indications. To salvage this situation, we devised a function which relied on inversion count to check whether the board is solvable or not! If the row index of the blank tile is even & inversion count is odd or if the row index of the blank tile is odd & inversion count is even, then the board is solvable. Thus the code first checks whether the board is solvable or not and proceeds to solve only if is, else returns Inf within a moment!

At last, all the variants for all the boards are working perfectly. We tried some worse test cases with 22 moves original, 16 moves circular, and two test cases for luddy too! Everything is working properly but our code is not giving output only for board4-luddy in time. We tried debugging the optimization many times but its not working for that case. We tried observing the state spaces it was traversing and it seemed fine. We also tried changing our heuristic function to manhattan distance hoping that it would be efficient and the result will come within time for this particular board of luddy variant! We also tried to do some changes with the g(x) as it was calculating the extra cases for the route traversed so for. We managed to resolve the infinite loop and we got a finite output for that case but that is not the optimal solution.

## Part 2: Road trip!

The first task was to read the two datasets- city-gps and road segments. The main challenge in reading the city-gps dataset was to ignore any discrepancy in it i.e. even if in some cases if the value of either latitude or longitude or both is missing, our code must accept it as an exception and run without interruption. The challenge in reading the road segments data is that all the roads given in that file were bi-directional. For this, we created a lists which stored all the inter-city details and also stored the reverse of the highway with the same details.

The problem was to find a path connecting two places, which was optimal for the given cost function. The cost function is one out of distance, time, mpg, and number of turns.

For finding the optimal path between the two given places, we used priority queue. The key of the priority queue is set according to the required cost function. Every element in the queue has the key along with the entire path traversed until that node, the distance covered until then, time taken, and the quantity of gas required to reach till that point. For the cost function- segments, the considered the length of the path covered. For every node, all the successors, except for the one that was already in the path, were checked for the specified cost function. In this way, we ensured that the path is always going in the forward direction. The code always explore the path with the least of all the cost functions irrespective of the length. 

The first element of the queue is taken which has all the details of the path traversed till that node. If the successor of a node is the destination, it returns the path found along with the distance, time, gallons of gas used and the path followed. The number of turns is derived from the length of the path. If no path exists between the given two cities, the code returns “inf” as the answer.


## Part 3: Choosing a team

For this problem we need to find the best team of robots with the total highest skills given a certain budget constraint. We are given all the robots cost and skill as input. We are not allowed to select fractional part of a robot. The robot is to be either selected completely or not selected. The solution should be such that in a given budget, the skills achieved should be maximum.

The first problem was to remove the fractional part of the robot, which the earlier code considered while selecting the team. This was because it was dividing the budget in hand with the cost of the robot and limiting the value to 1 or less than 1. It was sorting the list of all the robots based on the ratio of their skills and cost. This would have been beneficial in the case when multiple instances of a robot was allowed. To overcome this challenge, we considered a robot only if its cost is less than the remaining budget. This ensured that there is no fractional part in the final team.

For getting the solution to the problem, we first arrange the list of all the robots in a list in a descending order with respect to the skills they possess. After rearranging the robots, subsets of this list are created. The subsets will automatically be created in a manner that the combination with highest skills for a particular number of robots is the first element of the list. At first, the state space was very huge as the the total number of possible combinations were 2^n where n is total number of robots. To overcome this, only those combinations are kept in the set of possible combination which have overall cost less than or equal to the budget. This reduced the statespace significantly and the excution was faster.

Now, the important task was to sort all the combinations with respect to the combined skills of all the robots in each combination. First we tried using a list which had all possible combinations  and sorting it on the basis of the total skill of all the robots in a particular combination. It gave the desired results, however it was consuming so much time than expected. As an alternative to this method, we used Priority Queue whose key was set to the negative of the total skill for each combination. As a result, the queue was returning the element with lowest value but it had the highest magnitude of skill. After considering all the possible combinations, the first element of the queue was returned which had the best combination and its total skill. Implementing Priority Queue avoided the repeatitive list sorting in list implementation and thus, reducing the execution time drastically.
